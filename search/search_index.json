{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GTag GTag is a GUI toolkit for building beautiful (components based) applications for desktop, web, and mobile(android) from a single python3 codebase. GTag is a guy sub module : It's pure python3. It's like flutter , justpy , remi , fluent ... but based on guy , so it inherits of all guy's features OOTB (working in its own window gui (chrome or cef), working as a web server, working on all platforms, and can be released as apk/android, or a pypi app) It's a lot inspired from vuejs concepts (you will find components, lifecycle, own data, two ways data bindings, computed parts & state (like vuex)), but for python3 only. At start, it was just a test, a proof of concept. But, while things going working very well, with a minimal number of (<200) lines : it takes life as a real project, named gtag (with unitests covering 99% of the code) GTag 's name means \"Guy Tag\" (or GUI Tag) Follow the guide, let's get started click at bottom-right \u2198","title":"Introduction"},{"location":"#gtag","text":"GTag is a GUI toolkit for building beautiful (components based) applications for desktop, web, and mobile(android) from a single python3 codebase. GTag is a guy sub module : It's pure python3. It's like flutter , justpy , remi , fluent ... but based on guy , so it inherits of all guy's features OOTB (working in its own window gui (chrome or cef), working as a web server, working on all platforms, and can be released as apk/android, or a pypi app) It's a lot inspired from vuejs concepts (you will find components, lifecycle, own data, two ways data bindings, computed parts & state (like vuex)), but for python3 only. At start, it was just a test, a proof of concept. But, while things going working very well, with a minimal number of (<200) lines : it takes life as a real project, named gtag (with unitests covering 99% of the code) GTag 's name means \"Guy Tag\" (or GUI Tag) Follow the guide, let's get started click at bottom-right \u2198","title":"GTag"},{"location":"10_simplest/","text":"The simplest gtag app could look like this from gtag import GTag class Comp ( GTag ): size = ( 200 , 100 ) def build ( self ): return \"hello world\" app = Comp () app . run () Will produce (on Windows 10) Important the build() method is called at each rendering time.","title":"Simplest"},{"location":"10_simplest/#the-simplest-gtag-app-could-look-like-this","text":"from gtag import GTag class Comp ( GTag ): size = ( 200 , 100 ) def build ( self ): return \"hello world\" app = Comp () app . run () Will produce (on Windows 10) Important the build() method is called at each rendering time.","title":"The simplest gtag app could look like this"},{"location":"15_simplest/","text":"The simplest gtag app could look like this from gtag import GTag , Tag class Comp ( GTag ): size = ( 200 , 100 ) def build ( self ): return Tag . span ( \"hello world\" ) app = Comp () app . run () Will produce (on Ubuntu 20.04) Important Here ... the build() method return a Tag . (but it exactly the same rendering that the previous example) the build() method is called at each rendering time.","title":"Simplest2"},{"location":"15_simplest/#the-simplest-gtag-app-could-look-like-this","text":"from gtag import GTag , Tag class Comp ( GTag ): size = ( 200 , 100 ) def build ( self ): return Tag . span ( \"hello world\" ) app = Comp () app . run () Will produce (on Ubuntu 20.04) Important Here ... the build() method return a Tag . (but it exactly the same rendering that the previous example) the build() method is called at each rendering time.","title":"The simplest gtag app could look like this"},{"location":"20_interaction/","text":"A most complex gtag app (with interaction) could look like this from gtag import GTag , Tag class Comp ( GTag ): size = ( 200 , 100 ) def build ( self ): return Tag . div ( Tag . span ( \"hello world\" ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe () ), ) def clickMe ( self ): print ( \"You have clicked\" ) app = Comp () app . run () Important self.bind.clickMe() is the way to bind the interaction with the self.clickMe() . (It will produce a js statement for the onclick event) self.clickMe() is an event. At each call, it will update the rendering. the build() method is called at each rendering time.","title":"Interaction"},{"location":"20_interaction/#a-most-complex-gtag-app-with-interaction-could-look-like-this","text":"from gtag import GTag , Tag class Comp ( GTag ): size = ( 200 , 100 ) def build ( self ): return Tag . div ( Tag . span ( \"hello world\" ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe () ), ) def clickMe ( self ): print ( \"You have clicked\" ) app = Comp () app . run () Important self.bind.clickMe() is the way to bind the interaction with the self.clickMe() . (It will produce a js statement for the onclick event) self.clickMe() is an event. At each call, it will update the rendering. the build() method is called at each rendering time.","title":"A most complex gtag app (with interaction) could look like this"},{"location":"30_databind/","text":"A most complex gtag app (the interaction changes the value) could look like this from gtag import GTag , Tag class Comp ( GTag ): size = ( 200 , 100 ) def init ( self , value ): self . value = value def build ( self ): return Tag . div ( Tag . span ( \"hello\" , self . value ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe ( 1 ) ), ) def clickMe ( self , inc ): self . value += inc app = Comp ( 0 ) app . run () Important the init() method is called at constructor time, to initialize your component ;-) (see it like a classical __init__() , the real __init__ is reserved by the framework, to make the magic) the build() method is called at each rendering time, so the value will be incremented visually.","title":"Databinding"},{"location":"30_databind/#a-most-complex-gtag-app-the-interaction-changes-the-value-could-look-like-this","text":"from gtag import GTag , Tag class Comp ( GTag ): size = ( 200 , 100 ) def init ( self , value ): self . value = value def build ( self ): return Tag . div ( Tag . span ( \"hello\" , self . value ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe ( 1 ) ), ) def clickMe ( self , inc ): self . value += inc app = Comp ( 0 ) app . run () Important the init() method is called at constructor time, to initialize your component ;-) (see it like a classical __init__() , the real __init__ is reserved by the framework, to make the magic) the build() method is called at each rendering time, so the value will be incremented visually.","title":"A most complex gtag app (the interaction changes the value) could look like this"},{"location":"40_nested/","text":"A most complex gtag app (re-use the component) could look like this from gtag import GTag , Tag class Comp ( GTag ): def init ( self , value ): self . value = value def build ( self ): return Tag . div ( Tag . span ( \"hello\" , self . value ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe ( 1 ) ), ) def clickMe ( self , inc ): self . value += inc class App ( GTag ): size = ( 200 , 200 ) def init ( self , v1 , v2 , v3 ): self . v1 = v1 self . v2 = v2 self . v3 = v3 def build ( self ): return Tag . div ( Comp ( self . v1 ), Comp ( self . v2 ), Comp ( self . v3 ) ) app = App ( 1 , 2 , 3 ) app . run ()","title":"Componentize"},{"location":"40_nested/#a-most-complex-gtag-app-re-use-the-component-could-look-like-this","text":"from gtag import GTag , Tag class Comp ( GTag ): def init ( self , value ): self . value = value def build ( self ): return Tag . div ( Tag . span ( \"hello\" , self . value ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe ( 1 ) ), ) def clickMe ( self , inc ): self . value += inc class App ( GTag ): size = ( 200 , 200 ) def init ( self , v1 , v2 , v3 ): self . v1 = v1 self . v2 = v2 self . v3 = v3 def build ( self ): return Tag . div ( Comp ( self . v1 ), Comp ( self . v2 ), Comp ( self . v3 ) ) app = App ( 1 , 2 , 3 ) app . run ()","title":"A most complex gtag app (re-use the component) could look like this"},{"location":"50_understand_lifecyle/","text":"Understand the lifecycle At this step, you know 90% of the GTag 's features ! But you must understand how it works ... Consider this basic component : class Comp ( GTag ): def init ( self , value , cpt ): self . value = value def build ( self ): return Tag . button ( self . value , onclick = self . bind . inc () ) def inc ( self ): self . value += 1 You can use it like this (dynamic approach): class App ( GTag ): def init ( self ): self . v = 0 def build ( self ): return Tag . div ( Comp ( self . v ), self . v , ) Note The component is (re)created at each app's rendering. Because, it is declared in the app's build() method. Or like that (static approach): class App ( GTag ): def init ( self ): self . c = Comp ( 0 ) def build ( self ): return Tag . div ( self . c , self . c . value , ) Note The component is created in the app's init() (just one time). And it's just (re)rendered at each app's rendering. In this case, it holds the value (but it could be binded from the parent too) Visually : the result will be exactly the same ! But under the hood : there are a lot of differences ! There aren't good pratice, it will mainly depend on your needs/habits. But you will need to familiarize with this two ways of doing things. Dynamic approach is less error proof. Static approach is speeder (?!), but can give headaches and strange results if bad used (ex: bad used in a dynamic approach) TODO: COMPLETE","title":"Understand lifecyle"},{"location":"50_understand_lifecyle/#understand-the-lifecycle","text":"At this step, you know 90% of the GTag 's features ! But you must understand how it works ... Consider this basic component : class Comp ( GTag ): def init ( self , value , cpt ): self . value = value def build ( self ): return Tag . button ( self . value , onclick = self . bind . inc () ) def inc ( self ): self . value += 1 You can use it like this (dynamic approach): class App ( GTag ): def init ( self ): self . v = 0 def build ( self ): return Tag . div ( Comp ( self . v ), self . v , ) Note The component is (re)created at each app's rendering. Because, it is declared in the app's build() method. Or like that (static approach): class App ( GTag ): def init ( self ): self . c = Comp ( 0 ) def build ( self ): return Tag . div ( self . c , self . c . value , ) Note The component is created in the app's init() (just one time). And it's just (re)rendered at each app's rendering. In this case, it holds the value (but it could be binded from the parent too) Visually : the result will be exactly the same ! But under the hood : there are a lot of differences ! There aren't good pratice, it will mainly depend on your needs/habits. But you will need to familiarize with this two ways of doing things. Dynamic approach is less error proof. Static approach is speeder (?!), but can give headaches and strange results if bad used (ex: bad used in a dynamic approach) TODO: COMPLETE","title":"Understand the lifecycle"},{"location":"55_interact_with_js/","text":"Interact with js, in your binded events from gtag import GTag , Tag class InputText ( GTag ): def init ( self , value ): self . value = value def build ( self ): return Tag . input ( type = \"text\" , value = self . value , onchange = self . bind . select ( b \"this.value\" ) ) def select ( self , value ): self . value = value class App ( GTag ): size = ( 200 , 200 ) def init ( self , txt ): self . txt = txt def build ( self ): return Tag . div ( InputText ( self . txt ) , self . txt , ) app = App ( \"hello\" ) app . run () Note You can interact (your events) with JS side, by surrounding your js statement with b\"<js>\" : put a b fefore your strings (in py3: it means bytestring, but in GTag : it means \"bind\" ;-) ). Thus, the value of the html input element will be send to the python event/method. Interact more ! For power users only (js addicts). The gtag 's instance can render javascript code to be executed. When setted, the content will be executed on JS side, when rendering. It can be very practice to initialize some things in the frontend ! Exemple: class App ( GTag ): def init ( self ): self . cpt = 0 self ( \"alert(1)\" ) def build ( self ): self ( \"alert(2)\" ) return VBox ( self . cpt , Button ( \"++\" , onclick = self . bind . add ()) ) def add ( self ): self . cpt += 1 self ( \"alert(3)\" ) Each call of self(\"<js>\") will append the javascript code in the rendering process, and execute them in the frontend, according the order : init > (event) > build. when component is rendered, it will call alert(1) and alert(2) in the frontend. when you will click on [++], it will call alert(1) , alert(3) and alert(2) : calling event's add() will ends with the self.build() ! All script contents will be executed, after rendering (one time at the end), in a IIFE statement, with the parameter tag valued with the current domElement of the gtag. Note Understand that everything that is created in this context will be lost after execution.","title":"Interact with js"},{"location":"55_interact_with_js/#interact-with-js-in-your-binded-events","text":"from gtag import GTag , Tag class InputText ( GTag ): def init ( self , value ): self . value = value def build ( self ): return Tag . input ( type = \"text\" , value = self . value , onchange = self . bind . select ( b \"this.value\" ) ) def select ( self , value ): self . value = value class App ( GTag ): size = ( 200 , 200 ) def init ( self , txt ): self . txt = txt def build ( self ): return Tag . div ( InputText ( self . txt ) , self . txt , ) app = App ( \"hello\" ) app . run () Note You can interact (your events) with JS side, by surrounding your js statement with b\"<js>\" : put a b fefore your strings (in py3: it means bytestring, but in GTag : it means \"bind\" ;-) ). Thus, the value of the html input element will be send to the python event/method.","title":"Interact with js, in your binded events"},{"location":"55_interact_with_js/#interact-more","text":"For power users only (js addicts). The gtag 's instance can render javascript code to be executed. When setted, the content will be executed on JS side, when rendering. It can be very practice to initialize some things in the frontend ! Exemple: class App ( GTag ): def init ( self ): self . cpt = 0 self ( \"alert(1)\" ) def build ( self ): self ( \"alert(2)\" ) return VBox ( self . cpt , Button ( \"++\" , onclick = self . bind . add ()) ) def add ( self ): self . cpt += 1 self ( \"alert(3)\" ) Each call of self(\"<js>\") will append the javascript code in the rendering process, and execute them in the frontend, according the order : init > (event) > build. when component is rendered, it will call alert(1) and alert(2) in the frontend. when you will click on [++], it will call alert(1) , alert(3) and alert(2) : calling event's add() will ends with the self.build() ! All script contents will be executed, after rendering (one time at the end), in a IIFE statement, with the parameter tag valued with the current domElement of the gtag. Note Understand that everything that is created in this context will be lost after execution.","title":"Interact more !"},{"location":"60_hold_your_state/","text":"Hold your app state Each components got its own state. All components are recreated at each rendering .... except one : the main one. The main one is the grandfather of all others. It's the one which start the app ! It's the only component which will keep its state. And so, it's the perfect place to hold your state app ! Note If your application is runned in server mode (using app.serve() ) : You will have a main one per browser session. So your state is per session ! If you want to share a state between session, use your process state ! Each gtag components can access to : the main one : with self.main (If you are in the main one: self.parent is self ) the parent one : with self.parent (the gtag's parent which has created this child). If you are in the main one, self.parent is None So a child's component can interact with its parent : thru self.parent . So any components can interact which the main one, thru self.main . Good practice A good practice, if you came from flux/redux/vuex (or others state manager) : is to reuse the sames concepts/patterns in the main one . You declare main's methods to do your mutations/actions on the main'state. And, in your childs, you mutate your state with main's methods.","title":"Hold your state"},{"location":"60_hold_your_state/#hold-your-app-state","text":"Each components got its own state. All components are recreated at each rendering .... except one : the main one. The main one is the grandfather of all others. It's the one which start the app ! It's the only component which will keep its state. And so, it's the perfect place to hold your state app ! Note If your application is runned in server mode (using app.serve() ) : You will have a main one per browser session. So your state is per session ! If you want to share a state between session, use your process state ! Each gtag components can access to : the main one : with self.main (If you are in the main one: self.parent is self ) the parent one : with self.parent (the gtag's parent which has created this child). If you are in the main one, self.parent is None So a child's component can interact with its parent : thru self.parent . So any components can interact which the main one, thru self.main .","title":"Hold your app state"},{"location":"60_hold_your_state/#good-practice","text":"A good practice, if you came from flux/redux/vuex (or others state manager) : is to reuse the sames concepts/patterns in the main one . You declare main's methods to do your mutations/actions on the main'state. And, in your childs, you mutate your state with main's methods.","title":"Good practice"},{"location":"70_events/","text":"Manage your events Each gtag can declare its own methods, but those which are binded on Tag js events, are called events. Calling an event will produce a re-rendering of the app ! Theses events's methods can be declared as sync , async or async generator . Declaring your method/events Consider this gtag component : class App ( GTag ): def init ( self ): self . rows = [] def build ( self ): return Tag . div ( Tag . button ( \"reload\" , onclick = self . bind . clickMe () ), Table ( self . rows ) ) ... The 3 following declarations are valid : A sync method def clickMe ( self ): self . rows = [ ... ] The UI will wait the call. A async method async def clickMe ( self ): self . rows = await fetch () The UI will await the call. ( TODO: COMPLETE HERE ) A async generator method async def clickMe ( self ): self . rows = [] yield self . rows = await fetch () The UI will await the call. But it will produce two rendering consecutivly. ( TODO: COMPLETE HERE ) Start a method/event at start Sometimes, it can be useful to start a process at the start of the GUI (ie: fetching data on the internet) app = App () app . run ( start = app . clickMe () ) ( TODO: COMPLETE HERE )","title":"Manage your events"},{"location":"70_events/#manage-your-events","text":"Each gtag can declare its own methods, but those which are binded on Tag js events, are called events. Calling an event will produce a re-rendering of the app ! Theses events's methods can be declared as sync , async or async generator .","title":"Manage your events"},{"location":"70_events/#declaring-your-methodevents","text":"Consider this gtag component : class App ( GTag ): def init ( self ): self . rows = [] def build ( self ): return Tag . div ( Tag . button ( \"reload\" , onclick = self . bind . clickMe () ), Table ( self . rows ) ) ... The 3 following declarations are valid :","title":"Declaring your method/events"},{"location":"70_events/#a-sync-method","text":"def clickMe ( self ): self . rows = [ ... ] The UI will wait the call.","title":"A sync method"},{"location":"70_events/#a-async-method","text":"async def clickMe ( self ): self . rows = await fetch () The UI will await the call. ( TODO: COMPLETE HERE )","title":"A async method"},{"location":"70_events/#a-async-generator-method","text":"async def clickMe ( self ): self . rows = [] yield self . rows = await fetch () The UI will await the call. But it will produce two rendering consecutivly. ( TODO: COMPLETE HERE )","title":"A async generator method"},{"location":"70_events/#start-a-methodevent-at-start","text":"Sometimes, it can be useful to start a process at the start of the GUI (ie: fetching data on the internet) app = App () app . run ( start = app . clickMe () ) ( TODO: COMPLETE HERE )","title":"Start a method/event at start"},{"location":"80_optimize_rendering/","text":"Optimize your rendering Sometimes, if your component doesn't need to refresh all the app : it can re-render itself only. In this case, put the @render.local on your method/event, like this : from gtag import GTag , Tag , render class Comp ( GTag ): def init ( self , value ): self . value = value def build ( self ): return Tag . div ( Tag . span ( \"hello\" , self . value ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe ( 1 ) ), ) @render . local # <- here is the trick def clickMe ( self , inc ): self . value += inc class App ( GTag ): size = ( 200 , 200 ) def init ( self , v1 , v2 , v3 ): self . v1 = v1 self . v2 = v2 self . v3 = v3 def build ( self ): return Tag . div ( Comp ( self . v1 ), Comp ( self . v2 ), Comp ( self . v3 ) ) app = App ( 1 , 2 , 3 ) app . run () Note In this case, it makes a lot of sense : because Comp doesn't have any interactions with others. TODO: there is render.parent & render.none too !!!!!!!!!!!!!!!","title":"Optimize your rendering"},{"location":"80_optimize_rendering/#optimize-your-rendering","text":"Sometimes, if your component doesn't need to refresh all the app : it can re-render itself only. In this case, put the @render.local on your method/event, like this : from gtag import GTag , Tag , render class Comp ( GTag ): def init ( self , value ): self . value = value def build ( self ): return Tag . div ( Tag . span ( \"hello\" , self . value ), Tag . button ( \"Click me\" , onclick = self . bind . clickMe ( 1 ) ), ) @render . local # <- here is the trick def clickMe ( self , inc ): self . value += inc class App ( GTag ): size = ( 200 , 200 ) def init ( self , v1 , v2 , v3 ): self . v1 = v1 self . v2 = v2 self . v3 = v3 def build ( self ): return Tag . div ( Comp ( self . v1 ), Comp ( self . v2 ), Comp ( self . v3 ) ) app = App ( 1 , 2 , 3 ) app . run () Note In this case, it makes a lot of sense : because Comp doesn't have any interactions with others. TODO: there is render.parent & render.none too !!!!!!!!!!!!!!!","title":"Optimize your rendering"},{"location":"90_include_js_css/","text":"Customize your components It's the main goal, but waited the end to present you ;-) Til here, we worked with pure html/js components. But you can use any css/js libraries found on internet to help you to build marvelous frontend GUI (bulma, tailwind, materialize, etc ...). Here is an example using the marvelous materializecss : from gtag import GTag , Tag class Div ( GTag ): def build ( self ): return Tag . div ( * self . _args , ** self . _kargs ) class Text ( GTag ): def build ( self ): return Tag . p ( * self . _args , ** self . _kargs ) class Button ( GTag ): def build ( self ): return Tag . button ( * self . _args , ** self . _kargs , klass = \"waves-effect waves-light btn\" ) class MaterializeApp ( GTag ): size = ( 200 , 200 ) headers = [ Tag . script ( src = \"https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js\" ), Tag . link ( href = \"https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css\" , type = \"text/css\" , rel = \"stylesheet\" ), ] def build ( self ): return Div ( Text ( \"hello\" ), Button ( \"Button\" , onclick = self . bind . print () ), Div ( Div ( klass = \"indeterminate\" ), klass = \"progress\" ) ) def print ( self ): print ( \"hello\" ) t = MaterializeApp ( None ) t . run () In fact, each gtag components can declare js or css as static properties. There can be string or list of strings, referencing 'http ressources' or declarative content. When starting the app, all gtag 's js/css will be included in the html/headers, available for all the app/components. Note In this example: the http ressources are downloaded from the internet, in frontend side. But as a gtag app is an advanced guy app (which embbed its own http server) ; you can imagine putting files in the \"static\" folder of guy . So if your freeze it to a windows/exe, package as a pypi's app or build an apk : it will be automatically embedded in your app. TODO: perhaps a new page for the embedded content with guy's static folder ?!","title":"Customize your rendering"},{"location":"90_include_js_css/#customize-your-components","text":"It's the main goal, but waited the end to present you ;-) Til here, we worked with pure html/js components. But you can use any css/js libraries found on internet to help you to build marvelous frontend GUI (bulma, tailwind, materialize, etc ...). Here is an example using the marvelous materializecss : from gtag import GTag , Tag class Div ( GTag ): def build ( self ): return Tag . div ( * self . _args , ** self . _kargs ) class Text ( GTag ): def build ( self ): return Tag . p ( * self . _args , ** self . _kargs ) class Button ( GTag ): def build ( self ): return Tag . button ( * self . _args , ** self . _kargs , klass = \"waves-effect waves-light btn\" ) class MaterializeApp ( GTag ): size = ( 200 , 200 ) headers = [ Tag . script ( src = \"https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js\" ), Tag . link ( href = \"https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css\" , type = \"text/css\" , rel = \"stylesheet\" ), ] def build ( self ): return Div ( Text ( \"hello\" ), Button ( \"Button\" , onclick = self . bind . print () ), Div ( Div ( klass = \"indeterminate\" ), klass = \"progress\" ) ) def print ( self ): print ( \"hello\" ) t = MaterializeApp ( None ) t . run () In fact, each gtag components can declare js or css as static properties. There can be string or list of strings, referencing 'http ressources' or declarative content. When starting the app, all gtag 's js/css will be included in the html/headers, available for all the app/components. Note In this example: the http ressources are downloaded from the internet, in frontend side. But as a gtag app is an advanced guy app (which embbed its own http server) ; you can imagine putting files in the \"static\" folder of guy . So if your freeze it to a windows/exe, package as a pypi's app or build an apk : it will be automatically embedded in your app. TODO: perhaps a new page for the embedded content with guy's static folder ?!","title":"Customize your components"},{"location":"99_final_words/","text":"Tuto 100% completed Now, you've seen 100% of gtag 's features ;-) gtag is young ... fully tested (99% covered UT). But there might be bugs : you can declare them here But the promise is here : it can compete with flutter : you can release desktop, mobile or web applications from a single codebase ;-) TODO: talk about gtags Important In all cases; the server mode is not the main use/goal. So don't expect to make a big web site, handling millions of requests. Consider this mode, for little web app, with some users.","title":"Final words"},{"location":"99_final_words/#tuto-100-completed","text":"Now, you've seen 100% of gtag 's features ;-) gtag is young ... fully tested (99% covered UT). But there might be bugs : you can declare them here But the promise is here : it can compete with flutter : you can release desktop, mobile or web applications from a single codebase ;-) TODO: talk about gtags Important In all cases; the server mode is not the main use/goal. So don't expect to make a big web site, handling millions of requests. Consider this mode, for little web app, with some users.","title":"Tuto 100% completed"},{"location":"gtag/","text":"GTag TODO: COMPLETE static properties headers properties main Get the main GTag (which it's the grandfather of all GTag). Note In fact, it returns a proxy object, which expose all properties as \"Reactive properties\" and expose all methods. Important The main one is the perfect place to store the state of your app. Because the state is available from all gtags childs. (there is one main gtag by session (when runned in serve mode)) parent Get the parent GTag (which has created this child). It's None if you are in the main GTag. Note In fact, it returns a proxy object, which expose all properties as \"Reactive properties\" and expose all methods. method to implement init(...) The constructor, if you want to initialize the state of your component. build() The method to build the Tag . produce js in the component call self(\"<js>\") see Interact With js TODO: EXPLAIN MORE Run features Theses are the same as guy . (so you can expect : autoreload, limit one instance at runtime, etc ...) but you can add a start event to call a first async method at start ... TODO: EXPLAIN MORE run Use this to run as a desktop app (*), or a mobile application (only android) (*): you will need to have chrome/chromium installed, because it reuse it as a container. runCef Use this to run as a desktop app (use cefpython3 in place of chrome/chromium ^^). So it can be a standalone app (like an electron app). serve Use this to run as a web app. In this case, there will be one main gtag per browser session.","title":"GTag"},{"location":"gtag/#gtag","text":"TODO: COMPLETE","title":"GTag"},{"location":"gtag/#static-properties","text":"","title":"static properties"},{"location":"gtag/#headers","text":"","title":"headers"},{"location":"gtag/#properties","text":"","title":"properties"},{"location":"gtag/#main","text":"Get the main GTag (which it's the grandfather of all GTag). Note In fact, it returns a proxy object, which expose all properties as \"Reactive properties\" and expose all methods. Important The main one is the perfect place to store the state of your app. Because the state is available from all gtags childs. (there is one main gtag by session (when runned in serve mode))","title":"main"},{"location":"gtag/#parent","text":"Get the parent GTag (which has created this child). It's None if you are in the main GTag. Note In fact, it returns a proxy object, which expose all properties as \"Reactive properties\" and expose all methods.","title":"parent"},{"location":"gtag/#method-to-implement","text":"","title":"method to implement"},{"location":"gtag/#init","text":"The constructor, if you want to initialize the state of your component.","title":"init(...)"},{"location":"gtag/#build","text":"The method to build the Tag .","title":"build()"},{"location":"gtag/#produce-js-in-the-component","text":"call self(\"<js>\") see Interact With js TODO: EXPLAIN MORE","title":"produce js in the component"},{"location":"gtag/#run-features","text":"Theses are the same as guy . (so you can expect : autoreload, limit one instance at runtime, etc ...) but you can add a start event to call a first async method at start ... TODO: EXPLAIN MORE","title":"Run features"},{"location":"gtag/#run","text":"Use this to run as a desktop app (*), or a mobile application (only android) (*): you will need to have chrome/chromium installed, because it reuse it as a container.","title":"run"},{"location":"gtag/#runcef","text":"Use this to run as a desktop app (use cefpython3 in place of chrome/chromium ^^). So it can be a standalone app (like an electron app).","title":"runCef"},{"location":"gtag/#serve","text":"Use this to run as a web app. In this case, there will be one main gtag per browser session.","title":"serve"},{"location":"tag/","text":"Tag See Tag as an helper to help you to build your HTML elements : that's all. Build your own Tags Admit that you want to produce a textarea html element. You should do something like that : Now, you can produce textarea html elements: Tag . textarea ( ) #-> \"<textarea></textarea>\" Tag . textarea ( \"content\" ) #-> \"<textarea>content</textarea>\" Tag . textarea ( \"content1\" , \"content2\" , checked = True , data_info = \"mine\" , onclick = \"alert(42)\" ) #-> \"<textarea checked data-info='mine' onclick='alert(42)'>content1 content2</textarea>\" Tag . textarea ( klass = \"me\" ) #-> \"<textarea class='me'></textarea>\" Note As class is python reserved keyword, you must use \"klass\" Important The only html attribut you can't set is id . Because it is set by GTag when rendering the Tag . But if you need to set it, you can, on the Tag instance.(Keep in mind, that if the Tag is the main Tag produced by the GTag's build method, it may be overrided) Be aware, that Tag is a metaclass, it can produce all what you want : Tag . My_Reach_Mega_Tag ( \"content1\" , klass = \"yo\" ) #-> \"<My-Reach-Mega-Tag class=\"yo\">content1</My-Reach-Mega-Tag>\" You can add content to a Tag content can be anything, from string to GTag , or another Tag , anything that is string'able ;-) t = MyFormTag ( name = 'myform' , onsubmit = 'post(this)' ) t . add ( MyInputTag ( name = 'login' , value = '' ) ) t . add ( MyInputTag ( name = 'password' , type = 'password' , value = '' ) ) t . add ( \"ps: the password is 'foo' ;-) \" ) You can change/set properties of a Tag t = MyFormTag ( name = 'myform' , onsubmit = 'post(this)' ) t . onsubmit = \"post2(this)\" t . klass = \"aClassForMyForm\" t . id = \"f1\" # !!!","title":"Tag"},{"location":"tag/#tag","text":"See Tag as an helper to help you to build your HTML elements : that's all.","title":"Tag"},{"location":"tag/#build-your-own-tags","text":"Admit that you want to produce a textarea html element. You should do something like that : Now, you can produce textarea html elements: Tag . textarea ( ) #-> \"<textarea></textarea>\" Tag . textarea ( \"content\" ) #-> \"<textarea>content</textarea>\" Tag . textarea ( \"content1\" , \"content2\" , checked = True , data_info = \"mine\" , onclick = \"alert(42)\" ) #-> \"<textarea checked data-info='mine' onclick='alert(42)'>content1 content2</textarea>\" Tag . textarea ( klass = \"me\" ) #-> \"<textarea class='me'></textarea>\" Note As class is python reserved keyword, you must use \"klass\" Important The only html attribut you can't set is id . Because it is set by GTag when rendering the Tag . But if you need to set it, you can, on the Tag instance.(Keep in mind, that if the Tag is the main Tag produced by the GTag's build method, it may be overrided) Be aware, that Tag is a metaclass, it can produce all what you want : Tag . My_Reach_Mega_Tag ( \"content1\" , klass = \"yo\" ) #-> \"<My-Reach-Mega-Tag class=\"yo\">content1</My-Reach-Mega-Tag>\"","title":"Build your own Tags"},{"location":"tag/#you-can-add-content-to-a-tag","text":"content can be anything, from string to GTag , or another Tag , anything that is string'able ;-) t = MyFormTag ( name = 'myform' , onsubmit = 'post(this)' ) t . add ( MyInputTag ( name = 'login' , value = '' ) ) t . add ( MyInputTag ( name = 'password' , type = 'password' , value = '' ) ) t . add ( \"ps: the password is 'foo' ;-) \" )","title":"You can add content to a Tag"},{"location":"tag/#you-can-changeset-properties-of-a-tag","text":"t = MyFormTag ( name = 'myform' , onsubmit = 'post(this)' ) t . onsubmit = \"post2(this)\" t . klass = \"aClassForMyForm\" t . id = \"f1\" # !!!","title":"You can change/set properties of a Tag"}]}